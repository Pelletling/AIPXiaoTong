using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace Framework.Security
{
    public class RSAHelper
    {
        /// <summary>    
        /// RSA私钥格式转换，java->.net
        /// </summary>    
        /// <param name="privateKey">java生成的RSA私钥</param>    
        /// <returns></returns>    
        public static string RSAPrivateKeyJava2DotNet(string privateKey)
        {
            return RSAConvert.RSA.RSAPrivateKeyJava2DotNet(privateKey);
        }

        /// <summary>    
        /// RSA私钥格式转换，.net->java    
        /// </summary>    
        /// <param name="privateKey">.net生成的私钥</param>    
        /// <returns></returns>    
        public static string RSAPrivateKeyDotNet2Java(string privateKey)
        {
            return RSAConvert.RSA.RSAPrivateKeyDotNet2Java(privateKey);
        }


        /// <summary>    
        /// RSA公钥格式转换，java->.net    
        /// </summary>    
        /// <param name="publicKey">java生成的公钥</param>    
        /// <returns></returns>    
        public static string RSAPublicKeyJava2DotNet(string publicKey)
        {
            return RSAConvert.RSA.RSAPublicKeyJava2DotNet(publicKey);
        }

        /// <summary>    
        /// RSA公钥格式转换，.net->java    
        /// </summary>    
        /// <param name="publicKey">.net生成的公钥</param>    
        /// <returns></returns>    
        public static string RSAPublicKeyDotNet2Java(string publicKey)
        {
            return RSAConvert.RSA.RSAPublicKeyDotNet2Java(publicKey);
        }

        /// <summary>
        /// 根据私钥加密
        /// </summary>
        /// <param name="privateKey"></param>
        /// <param name="content"></param>
        /// <returns></returns>
        public static string EncryptByPrivateKey(string privateKey, string content)
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();

            rsa.FromXmlString(privateKey);

            var sign = Convert.ToBase64String(rsa.Encrypt(Encoding.UTF8.GetBytes(content), false));

            return sign;
        }

        /// <summary>
        /// 使用公钥进行RSA加密(分段加密)
        /// </summary>
        /// <param name="value"></param>
        /// <param name="certPath"></param>
        /// <returns></returns>
        public static string EncryptByPublicKey(string pulickKey, string content)
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();

            rsa.FromXmlString(pulickKey);
            int MaxBlockSize = (rsa.KeySize / 8) - 11;//单块最大长度
            var buffer = new byte[MaxBlockSize];
            if (Encoding.UTF8.GetBytes(content).Length <= MaxBlockSize)
                return Convert.ToBase64String(rsa.Encrypt(Encoding.UTF8.GetBytes(content), false));

            MemoryStream PlaiStream = new MemoryStream(Encoding.UTF8.GetBytes(content));
            MemoryStream CrypStream = new MemoryStream();
            byte[] Buffer = new byte[MaxBlockSize];
            int BlockSize = PlaiStream.Read(buffer, 0, MaxBlockSize);
            while (BlockSize > 0)
            {
                var ToEncrypt = new byte[BlockSize];
                Array.Copy(buffer, 0, ToEncrypt, 0, BlockSize);
                var Cryptograph = rsa.Encrypt(ToEncrypt, false);
                CrypStream.Write(Cryptograph, 0, Cryptograph.Length);

                BlockSize = PlaiStream.Read(Buffer, 0, MaxBlockSize);
            }
            return Convert.ToBase64String(CrypStream.ToArray(), Base64FormattingOptions.None);
        }


        //public static string EncryptByPublicKey(string pulickKey, string content)
        //{
        //    RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();

        //    byte[] cipherbytes;

        //    rsa.FromXmlString(pulickKey);

        //    cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(content), false);

        //    return Convert.ToBase64String(cipherbytes);
        //}

        /// <summary>
        /// 根据JAVA（SHA1WithRSA）加密
        /// </summary>
        /// <param name="content"></param>
        /// <param name="privateKey"></param>
        /// <param name="input_charset"></param>
        /// <returns></returns>
        public static string SHA1WithRSA(string content, string privateKey, Encoding encoding = null)
        {
            if (encoding == null) encoding = Encoding.UTF8;

            byte[] Data = encoding.GetBytes(content);

            RSACryptoServiceProvider rsa = RSAExt.DecodePemPrivateKey(privateKey);

            SHA1 sh = new SHA1CryptoServiceProvider();

            byte[] signData = rsa.SignData(Data, sh);

            return Convert.ToBase64String(signData);
        }

        /// <summary>  
        /// 根据JAVA（SHA1WithRSA）验签  
        /// </summary>  
        /// <param name="content">待验签字符串</param>  
        /// <param name="signedString">签名</param>  
        /// <param name="publicKey">公钥</param>  
        /// <param name="input_charset">编码格式</param>  
        /// <returns>true(通过),false(不通过)</returns>  
        public static bool SHA1WithRSAVerify(string content, string signedString, string publicKey, Encoding encoding = null)
        {
            if (encoding == null) encoding = Encoding.UTF8;

            bool result = false;

            byte[] Data = encoding.GetBytes(content);

            byte[] data = Convert.FromBase64String(signedString);

            RSAParameters paraPub = RSAExt.ConvertFromPublicKey(publicKey);

            RSACryptoServiceProvider rsaPub = new RSACryptoServiceProvider();

            rsaPub.ImportParameters(paraPub);

            SHA1 sh = new SHA1CryptoServiceProvider();

            result = rsaPub.VerifyData(Data, sh, data);

            return result;
        }



    }
}
